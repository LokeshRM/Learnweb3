// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract ChainLink is VRFConsumerBaseV2 {
    VRFCoordinatorV2Interface COORDINATOR;

    AggregatorV3Interface internal priceFeed;

    // Your subscription ID.
    uint64 s_subscriptionId;

    // Rinkeby coordinator.
    address vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;

    // The gas lane to use, which specifies the maximum gas price to bump to.
    bytes32 keyHash =
        0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;

    // Gas Limit for the processing of the callback request in the fulfillRandomWords() by VRFCoordinator
    uint32 callbackGasLimit = 100000;

    // The default is 3, but you can set this higher.
    uint16 requestConfirmations = 3;

    // retrieve 1 random value in one request.
    uint32 numValues = 1;

    // stores the random number from the chainlink vrf
    uint256 public randomNumber;

    // stores the modulo of random number
    uint256 public s_randomNumber;
    uint256 public s_requestId;
    address s_owner;

    /**
     * constructor inherits a VRFConsumerBase and initiate the values of owner, subscriptionId.
     * creates instances of VRFCoordinator and Aggregator
     */
    constructor(uint64 subscriptionId) VRFConsumerBaseV2(vrfCoordinator) {
        COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);
        s_owner = msg.sender;
        s_subscriptionId = subscriptionId;
        priceFeed = AggregatorV3Interface(
            0x8A753747A1Fa494EC906cE90E9f37563A8AF630e
        );
    }

    /**
     * @dev starts the process of requesting random number by calling VRFConsumerBase to call the COORDINATOR
     */
    function requestRandomWords() external onlyOwner {
        // Will revert if subscription is not set and funded.
        s_requestId = COORDINATOR.requestRandomWords(
            keyHash,
            s_subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numValues
        );
    }

    /**
     * @dev fulfillRandomness is called by VRFCoordinator when it receives a valid VRF proof.
     * This function is overrided to act upon the random number generated by Chainlink VRF.
     * param requestId  this ID is unique for the request we sent to the VRF Coordinator
     * @param randomWords this is a random unit256 array generated and returned to us by the VRF Coordinator
     */
    function fulfillRandomWords(
        uint256, /* requestId */
        uint256[] memory randomWords
    ) internal override {
        randomNumber = randomWords[0];
        s_randomNumber = randomWords[0] % 2000;
        if (s_randomNumber < 1000) {
            s_randomNumber += 1000;
        }
    }

    /**
     * @dev requests AggregatorV3 to get latest price of ETH
     * returns price of ETH in USD
     */
    function getLatestPrice() public view returns (int256) {
        (, int256 price, , , ) = priceFeed.latestRoundData();
        // for ETH / USD price is scaled up by 10 ** 8
        return price / 1e8;
    }

    /**
     * @dev compares ETH price and Random number
     * returns true if ETH Price is greater than random number or else false
     */
    function checkEthPrice() public view returns (bool) {
        // ETH Price in USD
        uint256 ethPrice = uint256(getLatestPrice());
        if (ethPrice > s_randomNumber) {
            return true;
        }
        return false;
    }

    modifier onlyOwner() {
        require(msg.sender == s_owner);
        _;
    }
}
